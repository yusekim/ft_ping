### NAME

```
ping — 네트워크 호스트에 ICMP ECHO_REQUEST 패킷 전송
```

---

### SYNOPSIS

```
ping [옵션 ...] 호스트 ...
```

---

### DESCRIPTION

```
ping은 ICMP 프로토콜의 필수 ECHO_REQUEST 다트그램을 사용하여
호스트 또는 게이트웨이로부터 ICMP ECHO_RESPONSE를 유도합니다.
ECHO_REQUEST 다트그램(“핑”)은 IP와 ICMP 헤더를 포함하며, 그 뒤에 “struct timeval”과
패킷을 채우기 위한 임의의 수의 "pad" 바이트가 이어집니다.
```

---

### OPTIONS

```
--address
        ICMP_ADDRESS 패킷 전송 (root 전용).

--mask
        --address와 동일합니다.

--echo
        ICMP_ECHO 패킷 전송 (기본값).

--timestamp
        ICMP_TIMESTAMP 패킷 전송.

-t, --type type
        type 타입의 패킷 전송.

-c, --count count
        count 개의 ECHO_RESPONSE 패킷을 전송(및 수신)한 후 중지합니다.

-d, --debug
        사용 중인 소켓에 SO_DEBUG 옵션을 설정합니다.

-f, --flood
        Flood ping.  각 ECHO_REQUEST 전송 시 점 "."을 출력하고,
        각 ECHO_REPLY 수신 시 백스페이스를 출력합니다.
        이를 통해 얼마나 많은 패킷이 손실되었는지 빠르게 확인할 수 있습니다.
        이 옵션은 super-user만 사용할 수 있으며, 네트워크에 큰 부하를 줄 수 있으므로
        주의해서 사용해야 합니다.

-i, --interval wait
        각 패킷 전송 사이에 wait 초 동안 대기합니다. 기본값은 1초입니다.
        이 옵션은 -f 옵션과 함께 사용할 수 없습니다.

-l, --preload preload
        preload가 지정되면, 일반 동작 모드로 들어가기 전에 가능한 한 빨리 preload 수 만큼의 패킷을 전송합니다.

-n, --numeric
        숫자 출력만 수행합니다. 호스트 주소에 대해 기호 이름 조회를 시도하지 않습니다.

-p, --pattern pattern
        전송하는 패킷을 채우기 위해 최대 16바이트의 "pad"를 지정할 수 있습니다.
        이는 네트워크의 데이터 의존 문제를 진단하는 데 유용합니다.
        예를 들어, “-p ff”는 전송되는 패킷을 모두 1(0xff)로 채웁니다.

-q, --quiet
        조용한 출력 모드입니다. 시작 시와 종료 시 요약 라인만 표시됩니다.

-R, --route
        경로 기록. ECHO_REQUEST 패킷에 RECORD_ROUTE 옵션을 포함하여,
        반환된 패킷의 경로 버퍼를 표시합니다.
        단, IP 헤더가 최대 9개의 경로만 기록할 수 있으므로 많은 호스트가 이 옵션을 무시하거나 버릴 수 있습니다.

-r, --ignore-routing
        일반 라우팅 테이블을 무시하고, 직접 연결된 네트워크의 호스트로 전송합니다.
        만약 호스트가 직접 연결된 네트워크에 없다면 오류가 반환됩니다.
        이 옵션은 예를 들어 routed(8)에 의해 인터페이스가 제거된 후,
        경로가 없는 인터페이스를 통해 로컬 호스트에 ping을 보낼 때 사용할 수 있습니다.

-s, --size packetsize
        전송할 데이터 바이트 수를 지정합니다. 기본값은 56이며,
        이는 ICMP 헤더 8바이트와 합쳐서 64바이트의 ICMP 데이터가 전송됨을 의미합니다.

-v, --verbose
        자세한 출력 모드입니다. ECHO_RESPONSE 이외의 ICMP 패킷이 수신되면 이를 나열합니다.

--ttl N
        패킷의 TTL(Time To Live)을 N으로 설정합니다.

-T, --tos num
        패킷의 서비스 유형(TOS)을 num으로 설정합니다.

-w, --timeout N
        N초 후에 패킷 전송을 중지합니다.

-W, --linger N
        응답을 기다리는 시간을 N초로 설정합니다.

--ip-timestamp flag
        "tsonly" 또는 "tsaddr" 중 하나인 flag 타입의 IP 타임스탬프를 설정합니다.

-?, --help
        도움말 목록을 표시합니다.

--usage
        간단한 사용법 메시지를 표시합니다.

-V, --version
        프로그램 버전을 출력합니다.
```

---

### 추가 설명

```
ping을 장애 격리를 위해 사용할 때는 먼저 로컬 호스트에서 실행하여
로컬 네트워크 인터페이스가 정상 작동하는지 확인해야 합니다.
그 후, 점점 멀어지는 호스트 및 게이트웨이에 대해 "ping"을 수행합니다.
왕복 시간과 패킷 손실 통계가 계산됩니다. 만약 중복 패킷이 수신되면,
패킷 손실 계산에는 포함되지 않으나, 그 왕복 시간은 최소/평균/최대 값 산출에 사용됩니다.
지정된 수의 패킷 전송(및 수신) 후 또는 SIGINT 신호로 프로그램이 종료되면
간단한 요약이 표시됩니다.

이 프로그램은 네트워크 테스트, 측정 및 관리 목적으로 설계되었습니다.
네트워크에 부하를 줄 수 있으므로 정상 운영 중이나 자동화 스크립트에서의 사용은
권장되지 않습니다.
```

---

### ICMP PACKET DETAILS

```
옵션 없이 구성된 IP 헤더는 20바이트입니다.
ICMP ECHO_REQUEST 패킷은 추가로 8바이트의 ICMP 헤더와 임의의 양의 데이터를 포함합니다.
packetsize가 지정되면 이는 추가 데이터의 크기를 나타내며 (기본값은 56),
따라서 ICMP ECHO_REPLY 패킷 내에 수신되는 데이터는 요청된 데이터 공간보다
항상 8바이트 더 많습니다 (ICMP 헤더 때문).

데이터 공간이 최소 8바이트 이상인 경우, ping은 이 공간의 처음 8바이트를 사용하여
왕복 시간 계산에 사용되는 타임스탬프를 포함합니다.
8바이트 미만의 pad가 지정되면 왕복 시간은 제공되지 않습니다.
```

---

### DUPLICATE AND DAMAGED PACKETS

```
ping은 중복 및 손상된 패킷을 보고합니다.
중복 패킷은 원칙적으로 발생해서는 안 되며, 부적절한 링크 레벨 재전송에 의해 발생하는 것으로 보입니다.
중복은 여러 상황에서 발생할 수 있으며, 낮은 수준의 중복이 반드시 좋은 신호는 아니지만
경우에 따라 문제의 징후일 수 있습니다.

손상된 패킷은 심각한 문제를 나타내며, 네트워크나 호스트 중 어딘가의 하드웨어 고장을
의심하게 만듭니다.
```

---

### TRYING DIFFERENT DATA PATTERNS

```
네트워크(또는 인터) 계층은 데이터 부분의 내용에 따라 패킷을 다르게 취급해서는 안됩니다.
그러나 데이터 의존적인 문제는 때때로 네트워크에 스며들어 오랜 기간 감지되지 않을 수 있습니다.
많은 경우 문제가 발생하는 특정 패턴은 충분한 "전환"이 없는 (예를 들어 전부 1 또는 전부 0)
또는 경계 부분에 몰려 있는 (거의 전부 0) 패턴 등입니다.
커맨드라인에서 모든 0으로 구성된 데이터 패턴을 지정하는 것만으로는 부족할 수 있으며,
문제가 되는 패턴은 데이터 링크 계층에서의 특성과, 사용자가 입력한 내용과
하드웨어 컨트롤러가 전송하는 내용 사이의 복잡한 관계 때문에 명확하지 않을 수 있습니다.

즉, 데이터 의존 문제가 발생한다면 이를 찾기 위해 많은 테스트를 수행해야 합니다.
운이 좋다면 네트워크를 통해 전송이 제대로 이루어지지 않거나 다른 유사한 길이의 파일보다
전송 시간이 훨씬 긴 파일을 발견할 수 있으며, 그 파일의 반복 패턴을 -p 옵션으로 테스트할 수 있습니다.
```

---

### TTL DETAILS

```
IP 패킷의 TTL(Time To Live) 값은 해당 패킷이 폐기되기 전까지 통과할 수 있는
최대 IP 라우터 수를 나타냅니다. 현재 관행으로는 인터넷상의 각 라우터가 TTL 값을 정확히 1씩 감소시킵니다.

TCP/IP 명세에서는 TCP 패킷의 TTL을 60으로 설정하도록 규정하고 있으나,
많은 시스템은 더 낮은 값을 사용합니다 (예: 4.3BSD는 30, 4.2는 15).

이 필드의 최대 가능한 값은 255이며, 대부분의 Unix 시스템은
ICMP ECHO_REQUEST 패킷의 TTL을 255로 설정합니다. 이로 인해 일부 호스트에는
"ping"은 성공하지만 telnet(1)이나 ftp(1)으로는 접속할 수 없는 경우가 발생합니다.

일반 동작 시, ping은 수신된 패킷의 TTL 값을 출력합니다.
원격 시스템이 ping 패킷을 수신할 때, TTL 필드에 대해 다음 중 하나를 수행할 수 있습니다:

•    변경하지 않음; 이는 4.3BSD-Tahoe 이전의 Berkeley Unix 시스템이 했던 방식입니다.
     이 경우, 수신된 패킷의 TTL 값은 255에서 라우터 수를 뺀 값이 됩니다.

•    255로 설정함; 이는 현재의 Berkeley Unix 시스템에서 사용하는 방식입니다.
     이 경우, 수신된 패킷의 TTL 값은 원격 시스템에서 ping을 보낸 호스트까지의
     경로상의 라우터 수를 뺀 255가 됩니다.

•    다른 값으로 설정함; 일부 시스템은 TCP 패킷과 동일한 값을 ICMP 패킷에도 사용하며,
     예를 들어 30 또는 60을 사용하거나 전혀 다른 값을 사용할 수 있습니다.
```

---

### BUGS

```
많은 호스트와 게이트웨이가 RECORD_ROUTE 옵션을 무시합니다.

IP 헤더의 최대 길이 제한으로 인해 RECORD_ROUTE와 같은 옵션은
완전히 유용하게 사용되기 어렵습니다. 이 문제에 대해 할 수 있는 조치는 많지 않습니다.

Flood ping은 일반적으로 권장되지 않으며, 브로드캐스트 주소에 대해 flood ping을
실행하는 것은 매우 통제된 상황에서만 사용해야 합니다.
```

---

### SEE ALSO

```
netstat(1), ifconfig(1), routed(8)
```

---

### HISTORY

```
ping 명령은 4.3BSD에서 처음 등장했습니다.
```

---

```
GNU Network Utilities	       February 9, 2019		 GNU Network Utilities
```
